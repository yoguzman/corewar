typedef struct		s_info_line
{
	char			*label;
	int				bytes_line;
	int				cost_line;
	char			*name_instr;
	char			**arg;
}					t_if;

typedef struct		s_list
{
	void			*content;
	size_t			content_size;
	long			nb;
	struct s_list	*next;
	struct s_list	*prev;
}					t_list;

pour utiliser le t_list *inf_line;

t_if *info_line;

while (inf_line)
{
	info_line = (t_if *)inf_line->content;

	utilisez info_line (se referer a la structure au dessus)

	inf_line = inf_line->next;
}

void		print_champ(t_header *champ, t_list *inf_line)
{
	formater l affichage comme il faut;
}

int			compile_champ(t_header *champ, char *name, t_list *inf_line)
{
	ecrit deja le header grace a champ;
	doit ecrire le reste du fichier grace a la structure decrite si dessus;
}

julien fait la fonction de parsing d instruction;

int		get_header(char **file, t_header *header)
{
	recuperer les differentes info de la structure header et renvoie un int contenant l index de la case de file contenant les instructions;
}

int		get_info_file(char **file, t_header *champ, t_list **inf_line)
{
	t_if info_line;
	i = get_header(file, header);

	while (file[i])
	{
		//enlever le label de la ligne d instruction si besoin et le stocke dans info_line->label;
		check_label(line, info_line);
		//pars_turfu est deja fait
		pars_turfu(ligne contenant juste une instructions, info_line);
		//remplir la structure info_line (sauf name_instr && arg)
		fill_info_line(info_line, line);

		list_push_back(inf_line, &info_line, size);
	}

	return (-1);
}
